#!/usr/bin/env python3
"""
EuroMillions Streamlit UI
========================

Single-page graphical interface for EuroMillions ML prediction system.
Provides data management, model training, prediction generation, and export functionality.
"""

import os
import json
import streamlit as st
import pandas as pd
from datetime import datetime
from pathlib import Path
import sys

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from streamlit_adapters import (
    init_full_history,
    update_incremental,
    train_from_scratch,
    reload_models,
    get_scores,
    suggest_tickets_ui,
    fetch_last_draws,
    export_all_draws_csv,
    get_system_status
)

# Page configuration
st.set_page_config(
    page_title="EuroMillions — Console Graphique", 
    page_icon="🎲", 
    layout="centered"
)

def load_env_settings():
    """Load current .env settings."""
    env_file = Path(".env")
    settings = {
        "STORAGE_DIR": "./data",
        "DB_URL": "sqlite:///./data/draws.db", 
        "USER_AGENT": "EuromillionsPro/1.0 (+contact)",
        "REQUEST_TIMEOUT": "15",
        "MAX_RETRIES": "3"
    }
    
    if env_file.exists():
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"\'')
                    if key in settings:
                        settings[key] = value
    
    return settings

def save_env_settings(settings):
    """Save settings to .env file."""
    env_content = []
    env_content.append("# EuroMillions Configuration")
    env_content.append("# Generated by Streamlit UI")
    env_content.append(f"# Updated: {datetime.now().isoformat()}")
    env_content.append("")
    
    for key, value in settings.items():
        env_content.append(f'{key}="{value}"')
    
    env_content.append("")
    
    with open(".env", 'w', encoding='utf-8') as f:
        f.write('\n'.join(env_content))

def format_tickets_display(tickets):
    """Format tickets for display."""
    if not tickets:
        return "Aucun ticket généré"
    
    display_lines = []
    for ticket in tickets:
        balls_str = ticket['balls_str']
        stars_str = ticket['stars_str']
        display_lines.append(f"**{ticket['ticket_id']}.** {balls_str} | ⭐ {stars_str}")
    
    return '\n\n'.join(display_lines)

def main():
    """Main Streamlit application."""
    
    # Title and header
    st.title("🎲 EuroMillions — Console Graphique")
    st.markdown("Interface de gestion complète pour le système de prédiction EuroMillions")
    
    # Sidebar configuration
    with st.sidebar:
        st.header("🎯 Suggestions")
        
        # Suggestion parameters
        n_tickets = st.slider(
            "Nombre de tickets",
            min_value=1,
            max_value=20,
            value=10,
            help="Nombre de combinaisons à générer"
        )
        
        method = st.selectbox(
            "Méthode de génération",
            options=["hybrid", "topk", "random"],
            index=0,
            help="Stratégie de sélection des numéros"
        )
        
        seed = st.number_input(
            "Graine aléatoire",
            min_value=1,
            max_value=9999,
            value=42,
            help="Pour reproductibilité des résultats"
        )
        
        st.markdown("---")
        
        # Settings expander
        with st.expander("⚙️ Paramètres (.env)"):
            st.subheader("Configuration système")
            
            # Load current settings
            current_settings = load_env_settings()
            
            # Settings form
            with st.form("env_settings"):
                new_settings = {}
                
                new_settings["STORAGE_DIR"] = st.text_input(
                    "Répertoire de stockage",
                    value=current_settings["STORAGE_DIR"],
                    help="Dossier pour les données"
                )
                
                new_settings["DB_URL"] = st.text_input(
                    "URL de base de données",
                    value=current_settings["DB_URL"],
                    help="Chemin vers la base SQLite"
                )
                
                new_settings["USER_AGENT"] = st.text_input(
                    "User Agent",
                    value=current_settings["USER_AGENT"],
                    help="Identification pour les requêtes web"
                )
                
                new_settings["REQUEST_TIMEOUT"] = st.text_input(
                    "Timeout requêtes (sec)",
                    value=current_settings["REQUEST_TIMEOUT"],
                    help="Délai d'attente des requêtes"
                )
                
                new_settings["MAX_RETRIES"] = st.text_input(
                    "Nombre de tentatives",
                    value=current_settings["MAX_RETRIES"],
                    help="Retries en cas d'échec"
                )
                
                if st.form_submit_button("💾 Enregistrer paramètres"):
                    try:
                        save_env_settings(new_settings)
                        st.success("✅ Paramètres sauvegardés dans .env")
                        st.rerun()
                    except Exception as e:
                        st.error(f"❌ Erreur lors de la sauvegarde: {e}")
    
    # Main content sections
    
    # Section 1: Initialization & Updates
    st.header("🔧 Initialisation & Mise à jour")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("📥 Télécharger l'historique & Initialiser", use_container_width=True):
            with st.spinner("Téléchargement de l'historique complet..."):
                try:
                    result = init_full_history()
                    
                    if result.get("success", False):
                        st.success(f"✅ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"❌ {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"❌ Erreur lors de l'initialisation: {e}")
    
    with col2:
        if st.button("🔄 Mettre à jour (derniers tirages)", use_container_width=True):
            with st.spinner("Mise à jour des derniers tirages..."):
                try:
                    result = update_incremental()
                    
                    if result.get("success", False):
                        st.success(f"✅ {result['message']}")
                        st.json(result)
                    else:
                        st.error(f"❌ {result['message']}")
                        st.json(result)
                        
                except Exception as e:
                    st.error(f"❌ Erreur lors de la mise à jour: {e}")
    
    st.markdown("---")
    
    # Section 2: Training
    st.header("🧠 Entraînement")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("🏋️ Entraîner (from scratch)", use_container_width=True):
            with st.spinner("Entraînement des modèles en cours..."):
                try:
                    result = train_from_scratch()
                    
                    if result.get("success", False):
                        st.success(f"✅ {result['message']}")
                        
                        # Display training metrics
                        metrics_col1, metrics_col2 = st.columns(2)
                        with metrics_col1:
                            if result.get("main_logloss"):
                                st.metric("Log-loss boules principales", f"{result['main_logloss']:.4f}")
                        with metrics_col2:
                            if result.get("star_logloss"):
                                st.metric("Log-loss étoiles", f"{result['star_logloss']:.4f}")
                        
                        if result.get("training_data_size"):
                            st.info(f"📊 Données d'entraînement: {result['training_data_size']} tirages")
                    else:
                        st.error(f"❌ {result['message']}")
                        
                except Exception as e:
                    st.error(f"❌ Erreur lors de l'entraînement: {e}")
    
    with col2:
        if st.button("📦 Recharger le modèle", use_container_width=True):
            with st.spinner("Rechargement du modèle..."):
                try:
                    result = reload_models()
                    
                    if result.get("success", False):
                        st.success(f"✅ {result['message']}")
                        
                        if result.get("trained_at"):
                            st.info(f"📅 Entraîné le: {result['trained_at']}")
                    else:
                        st.error(f"❌ {result['message']}")
                        
                except Exception as e:
                    st.error(f"❌ Erreur lors du rechargement: {e}")
    
    st.markdown("---")
    
    # Section 3: Current Probabilities
    st.header("📊 Probabilités actuelles")
    
    if st.button("🔄 Actualiser les probabilités"):
        with st.spinner("Calcul des probabilités..."):
            try:
                balls_df, stars_df = get_scores()
                
                if not balls_df.empty and not stars_df.empty:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.subheader("🎱 Top 15 boules principales")
                        top_balls = balls_df.head(15)
                        st.dataframe(
                            top_balls[['ball', 'percentage', 'rank']].rename(columns={
                                'ball': 'Boule',
                                'percentage': 'Probabilité (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                    
                    with col2:
                        st.subheader("⭐ Top 5 étoiles")
                        top_stars = stars_df.head(5)
                        st.dataframe(
                            top_stars[['star', 'percentage', 'rank']].rename(columns={
                                'star': 'Étoile',
                                'percentage': 'Probabilité (%)',
                                'rank': 'Rang'
                            }),
                            use_container_width=True,
                            hide_index=True
                        )
                else:
                    st.warning("⚠️ Aucune probabilité disponible. Entraînez d'abord un modèle.")
                    
            except Exception as e:
                st.error(f"❌ Erreur lors du calcul des probabilités: {e}")
    
    st.markdown("---")
    
    # Section 4: Generate Tickets
    st.header("🎫 Générer des tickets 5+2")
    
    if st.button("🎲 Générer les tickets", use_container_width=True):
        with st.spinner(f"Génération de {n_tickets} tickets avec la méthode {method}..."):
            try:
                tickets = suggest_tickets_ui(n_tickets, method, seed)
                
                if tickets:
                    st.success(f"✅ {len(tickets)} tickets générés avec succès!")
                    
                    # Display tickets
                    st.subheader("🎫 Vos tickets EuroMillions")
                    
                    tickets_text = format_tickets_display(tickets)
                    st.markdown(tickets_text)
                    
                    # Prepare download data
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                    # CSV format
                    csv_data = []
                    csv_data.append("Ticket,Boule1,Boule2,Boule3,Boule4,Boule5,Etoile1,Etoile2")
                    for ticket in tickets:
                        balls = ticket['balls']
                        stars = ticket['stars']
                        csv_data.append(f"{ticket['ticket_id']},{balls[0]},{balls[1]},{balls[2]},{balls[3]},{balls[4]},{stars[0]},{stars[1]}")
                    csv_content = '\n'.join(csv_data)
                    
                    # JSON format
                    json_content = json.dumps({
                        "generated_at": datetime.now().isoformat(),
                        "method": method,
                        "seed": seed,
                        "tickets": tickets
                    }, indent=2, ensure_ascii=False)
                    
                    # Download buttons
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.download_button(
                            label="⬇️ Télécharger CSV",
                            data=csv_content,
                            file_name=f"euromillions_tickets_{timestamp}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                    
                    with col2:
                        st.download_button(
                            label="⬇️ Télécharger JSON",
                            data=json_content,
                            file_name=f"euromillions_tickets_{timestamp}.json",
                            mime="application/json",
                            use_container_width=True
                        )
                    
                    # Method explanation
                    st.info(f"**Méthode utilisée:** {method} | **Graine:** {seed}")
                    
                    method_explanations = {
                        "topk": "Sélectionne les boules/étoiles avec les plus hautes probabilités",
                        "random": "Échantillonnage aléatoire pondéré par les probabilités",
                        "hybrid": "Mélange de prédictions top et d'échantillonnage aléatoire"
                    }
                    
                    st.caption(method_explanations.get(method, "Méthode personnalisée"))
                
                else:
                    st.warning("⚠️ Aucun ticket généré. Vérifiez que les modèles sont entraînés.")
                    
            except Exception as e:
                st.error(f"❌ Erreur lors de la génération: {e}")
    
    st.markdown("---")
    
    # Section 5: History
    st.header("🗂️ Historique")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("📜 Voir les 20 derniers tirages", use_container_width=True):
            with st.spinner("Chargement de l'historique..."):
                try:
                    recent_draws = fetch_last_draws(20)
                    
                    if not recent_draws.empty:
                        st.subheader("📋 Derniers tirages")
                        
                        # Format for display
                        display_df = recent_draws[['draw_date', 'balls', 'stars']].rename(columns={
                            'draw_date': 'Date',
                            'balls': 'Boules principales',
                            'stars': 'Étoiles'
                        })
                        
                        st.dataframe(
                            display_df,
                            use_container_width=True,
                            hide_index=True
                        )
                    else:
                        st.warning("⚠️ Aucun tirage trouvé dans l'historique.")
                        
                except Exception as e:
                    st.error(f"❌ Erreur lors du chargement: {e}")
    
    with col2:
        if st.button("⬇️ Exporter l'historique (CSV)", use_container_width=True):
            with st.spinner("Préparation de l'export..."):
                try:
                    filename, csv_bytes = export_all_draws_csv()
                    
                    if csv_bytes:
                        st.download_button(
                            label="📁 Télécharger l'historique complet",
                            data=csv_bytes,
                            file_name=filename,
                            mime="text/csv",
                            use_container_width=True
                        )
                        
                        file_size = len(csv_bytes)
                        st.success(f"✅ Export prêt: {filename} ({file_size:,} octets)")
                    else:
                        st.warning("⚠️ Aucune donnée à exporter.")
                        
                except Exception as e:
                    st.error(f"❌ Erreur lors de l'export: {e}")
    
    # Footer with system status
    st.markdown("---")
    
    with st.expander("ℹ️ État du système"):
        try:
            status = get_system_status()
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("📊 Données")
                if status.get("data", {}).get("available", False):
                    data_info = status["data"]
                    st.success(f"✅ {data_info['count']} tirages disponibles")
                    if data_info.get("first_date") and data_info.get("last_date"):
                        st.caption(f"Du {data_info['first_date']} au {data_info['last_date']}")
                else:
                    st.error("❌ Aucune donnée disponible")
            
            with col2:
                st.subheader("🤖 Modèles")
                if status.get("models", {}).get("available", False):
                    model_info = status["models"]
                    st.success("✅ Modèles disponibles")
                    if model_info.get("trained_at"):
                        st.caption(f"Entraînés le: {model_info['trained_at']}")
                else:
                    st.error("❌ Aucun modèle entraîné")
            
            # Recommendations
            recommendations = status.get("recommendations", [])
            if recommendations:
                st.subheader("💡 Recommandations")
                for rec in recommendations:
                    st.info(f"• {rec}")
                    
        except Exception as e:
            st.error(f"❌ Erreur lors de la récupération du statut: {e}")


if __name__ == "__main__":
    main()
